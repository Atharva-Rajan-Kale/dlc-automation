# .github/workflows/security-analysis.yml
name: Security Analysis & Vulnerability Management

on:
  workflow_dispatch:
    inputs:
      current_version:
        description: 'Current version (e.g., 1.4.0)'
        required: true
        type: string
      previous_version:
        description: 'Previous version (e.g., 1.3.0)'
        required: true
        type: string
      fork_url:
        description: 'Your fork URL'
        required: true
        type: string
      pr_number:
        description: 'PR number to analyze (optional)'
        required: false
        type: string
      analysis_type:
        description: 'Type of security analysis'
        required: true
        type: choice
        options:
          - 'full-analysis'
          - 'deterministic-only'
          - 'monitor-only'
          - 'fix-vulnerabilities'
        default: 'full-analysis'
      max_wait_minutes:
        description: 'Max minutes to wait for security tests'
        required: false
        type: number
        default: 180

  schedule:
    # Run security analysis daily at 2 AM UTC
    - cron: '0 2 * * *'

env:
  PYTHONPATH: ${{ github.workspace }}/src
  REGION: us-east-1

jobs:
  security-setup:
    runs-on: ubuntu-latest
    outputs:
      should-run-analysis: ${{ steps.check.outputs.should-run }}
      analysis-type: ${{ steps.check.outputs.analysis-type }}
    steps:
      - name: Check if security analysis should run
        id: check
        run: |
          if [ "${{ github.event_name }}" == "schedule" ]; then
            echo "should-run=true" >> $GITHUB_OUTPUT
            echo "analysis-type=monitor-only" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "should-run=true" >> $GITHUB_OUTPUT
            echo "analysis-type=${{ inputs.analysis_type }}" >> $GITHUB_OUTPUT
          else
            echo "should-run=false" >> $GITHUB_OUTPUT
          fi

  security-analysis:
    runs-on: ubuntu-latest
    needs: security-setup
    if: needs.security-setup.outputs.should-run == 'true'
    timeout-minutes: 240
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.REGION }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements_agent.txt
          
          # Install GitHub CLI for PR interaction
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
          sudo apt-get update
          sudo apt-get install -y gh

      - name: Configure environment
        run: |
          echo "ACCOUNT_ID=${{ secrets.ACCOUNT_ID }}" >> $GITHUB_ENV
          echo "REGION=${{ env.REGION }}" >> $GITHUB_ENV
          
          # CodeBuild credentials for log access
          echo "CODEBUILD_AWS_ACCESS_KEY_ID=${{ secrets.CODEBUILD_ACCESS_KEY_ID }}" >> $GITHUB_ENV
          echo "CODEBUILD_AWS_SECRET_ACCESS_KEY=${{ secrets.CODEBUILD_SECRET_ACCESS_KEY }}" >> $GITHUB_ENV
          echo "CODEBUILD_AWS_SESSION_TOKEN=${{ secrets.CODEBUILD_AWS_SESSION_TOKEN }}" >> $GITHUB_ENV
          echo "CODEBUILD_REGION=${{ env.REGION }}" >> $GITHUB_ENV
          
          # Bedrock credentials for AI analysis
          echo "BEDROCK_INFERENCE_PROFILE_ARN=${{ secrets.BEDROCK_INFERENCE_PROFILE_ARN }}" >> $GITHUB_ENV
          echo "BEDROCK_AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}" >> $GITHUB_ENV
          echo "BEDROCK_AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}" >> $GITHUB_ENV
          echo "BEDROCK_AWS_SESSION_TOKEN=${{ secrets.AWS_SESSION_TOKEN }}" >> $GITHUB_ENV
          echo "BEDROCK_REGION=${{ env.REGION }}" >> $GITHUB_ENV
          
          # GitHub token for PR access
          echo "GITHUB_TOKEN=${{ secrets.GITHUB_TOKEN }}" >> $GITHUB_ENV

      - name: Run security analysis
        id: security
        run: |
          echo "🔒 Starting security analysis..."
          
          # Determine version inputs based on trigger
          if [ "${{ github.event_name }}" == "schedule" ]; then
            # For scheduled runs, use latest version or default
            current_version="1.4.0"  # Update this as needed
            previous_version="1.3.0"
            fork_url="https://github.com/your-username/deep-learning-containers"  # Update this
          else
            current_version="${{ inputs.current_version }}"
            previous_version="${{ inputs.previous_version }}"
            fork_url="${{ inputs.fork_url }}"
          fi
          
          # Build command based on analysis type
          case "${{ needs.security-setup.outputs.analysis-type }}" in
            "full-analysis")
              python security_test_agent.py \
                --current-version="$current_version" \
                --previous-version="$previous_version" \
                --fork-url="$fork_url"
              ;;
            "deterministic-only")
              python security_test_agent.py \
                --current-version="$current_version" \
                --previous-version="$previous_version" \
                --fork-url="$fork_url" \
                --deterministic-only
              ;;
            "monitor-only")
              echo "🔍 Running security monitoring..."
              python -c "
              from security_test_agent import SecurityTestAgent
              agent = SecurityTestAgent('$current_version', '$previous_version', '$fork_url')
              pr_number = agent.get_current_pr_number()
              if pr_number:
                  print(f'Monitoring PR #{pr_number}')
                  status = agent.monitor_pr_status(pr_number)
                  print(f'Security test status: {status}')
              else:
                  print('No open PR found for monitoring')
              "
              ;;
            "fix-vulnerabilities")
              python security_test_agent.py \
                --current-version="$current_version" \
                --previous-version="$previous_version" \
                --fork-url="$fork_url" \
                --auto-fix
              ;;
          esac
        continue-on-error: true

      - name: Parse security results
        id: results
        if: always()
        run: |
          echo "📊 Parsing security analysis results..."
          
          # Check if security log exists
          if [ -f "automation_logs/security_test.log" ]; then
            # Extract key metrics from log
            vulnerabilities_found=$(grep -c "vulnerability found" automation_logs/security_test.log || echo "0")
            vulnerabilities_fixed=$(grep -c "vulnerability fixed" automation_logs/security_test.log || echo "0")
            tests_analyzed=$(grep -c "security test analyzed" automation_logs/security_test.log || echo "0")
            
            echo "vulnerabilities-found=$vulnerabilities_found" >> $GITHUB_OUTPUT
            echo "vulnerabilities-fixed=$vulnerabilities_fixed" >> $GITHUB_OUTPUT
            echo "tests-analyzed=$tests_analyzed" >> $GITHUB_OUTPUT
            
            # Check for critical issues
            if grep -q "CRITICAL" automation_logs/security_test.log; then
              echo "has-critical=true" >> $GITHUB_OUTPUT
            else
              echo "has-critical=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "No security log found"
            echo "vulnerabilities-found=0" >> $GITHUB_OUTPUT
            echo "vulnerabilities-fixed=0" >> $GITHUB_OUTPUT
            echo "tests-analyzed=0" >> $GITHUB_OUTPUT
            echo "has-critical=false" >> $GITHUB_OUTPUT
          fi

      - name: Upload security analysis artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-analysis-${{ needs.security-setup.outputs.analysis-type }}-${{ github.run_number }}
          path: |
            automation_logs/security*.log
            security_analysis_results/
            vulnerability_reports/
            allowlist_updates/
          retention-days: 30

      - name: Generate security report
        if: always()
        run: |
          echo "## 🔒 Security Analysis Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Analysis Type:** ${{ needs.security-setup.outputs.analysis-type }}" >> $GITHUB_STEP_SUMMARY
          echo "**Trigger:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** ${{ steps.security.outcome }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### 📊 Results Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Vulnerabilities Found:** ${{ steps.results.outputs.vulnerabilities-found }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Vulnerabilities Fixed:** ${{ steps.results.outputs.vulnerabilities-fixed }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Tests Analyzed:** ${{ steps.results.outputs.tests-analyzed }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Critical Issues:** ${{ steps.results.outputs.has-critical }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Add recent log output if available
          if [ -f "automation_logs/security_test.log" ]; then
            echo "### 📝 Recent Log Output" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            tail -30 automation_logs/security_test.log >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          fi

      - name: Check for critical security issues
        if: steps.results.outputs.has-critical == 'true'
        run: |
          echo "🚨 Critical security vulnerabilities detected!"
          echo "Please review the security analysis artifacts and take immediate action."
          
          # Optionally fail the workflow for critical issues
          if [ "${{ needs.security-setup.outputs.analysis-type }}" != "monitor-only" ]; then
            exit 1
          fi

  vulnerability-tracking:
    runs-on: ubuntu-latest
    needs: [security-setup, security-analysis]
    if: always() && needs.security-setup.outputs.should-run == 'true'
    steps:
      - name: Update vulnerability tracking
        run: |
          echo "📋 Updating vulnerability tracking..."
          
          # Here you could integrate with your issue tracking system
          # For example, create GitHub issues for new vulnerabilities
          
          if [ "${{ needs.security-analysis.outputs.vulnerabilities-found }}" -gt "0" ]; then
            echo "Found ${{ needs.security-analysis.outputs.vulnerabilities-found }} vulnerabilities"
            # Add logic to create or update tracking issues
          fi
          
          if [ "${{ needs.security-analysis.outputs.vulnerabilities-fixed }}" -gt "0" ]; then
            echo "Fixed ${{ needs.security-analysis.outputs.vulnerabilities-fixed }} vulnerabilities"
            # Add logic to close resolved tracking issues
          fi

      - name: Send notifications
        if: needs.security-analysis.outputs.has-critical == 'true'
        run: |
          echo "🚨 Sending critical vulnerability notifications..."
          # Add your notification logic here (Slack, email, etc.)
          echo "Critical vulnerabilities found in security analysis"
          echo "Workflow: ${{ github.workflow }}"
          echo "Run: ${{ github.run_number }}"
          echo "Analysis Type: ${{ needs.security-setup.outputs.analysis-type }}"